module modhash
 use iso_fortran_env,only:int32,real32,real64
 implicit none
 private
 public::hash,roundinguppower2

 integer(int32), parameter, public :: seed_hash = 305419896_int32
 
 interface hash
  module procedure hashchar, hashint32, hashreal32, hashint32_scal, hashreal32_scal
 end interface

contains

pure function hashchar(k, seed) result(c)
 character(len=*), intent(in) :: k
 integer(int32), intent(in), optional :: seed
 integer(int32) :: c
 
 integer(int32) :: lenk, length, i
 integer(int32), allocatable :: kint32(:)

 lenk = len(k)

 length = int(lenk/4_int32)
 if(mod(lenk,4).ne.0) length = length + 1

 allocate(kint32(length))

 do i=1,lenk,4
  kint32(i) = transfer(k(i:min(i+3,lenk)),kint32(i))
 enddo
 
 if(present(seed))then
  c = hashint32(kint32, seed)
 else
  c = hashint32(kint32)
 endif
end function

pure function hashint32(k, seed) result(c)
 integer(kind=int32),intent(in)::k(:)
 integer(kind=int32), intent(in), optional :: seed

 integer(kind=int32) :: length
 integer(kind=int32) :: a,b,c
 integer(kind=int32) :: pos
 
 integer(kind=int32) :: seed_

 seed_ = seed_hash
 if(present(seed)) seed_ = seed

 length=size(k) 

 a=seed_ + ishft(length,2)
 b=a
 c=a

 pos=1
 do while (length > 3)
  a=a+k(pos)
  b=b+k(pos+1)
  c=c+k(pos+2)
  call mix(a,b,c)
  length=length-3
  pos=pos+3
 end do 

 select case(length)
  case(1)
   a=a+k(pos)
  case(2)
   a=a+k(pos)
   b=b+k(pos+1)
  case(3)
   a=a+k(pos)
   b=b+k(pos+1)
   c=c+k(pos+2)
  case default
 end select

 call final(a,b,c)

end function

pure function hashreal32(k, seed) result(c)
 real(kind=real32),intent(in)::k(:)
 integer(kind=int32), intent(in), optional :: seed

 integer(kind=int32) :: length
 integer(kind=int32) :: a,b,c
 integer(kind=int32) :: pos
 
 integer(kind=int32) :: seed_

 seed_ = seed_hash
 if(present(seed)) seed_ = seed

 length=size(k) 

 a=seed_ + ishft(length,2)
 b=a
 c=a

 pos=1
 do while (length > 3)
  a=a+transfer(k(pos),a)
  b=b+transfer(k(pos+1),b)
  c=c+transfer(k(pos+2),c)
  call mix(a,b,c)
  length=length-3
  pos=pos+3
 end do 

 select case(length)
  case(1)
   a=a+transfer(k(pos),a)
  case(2)
   a=a+transfer(k(pos),a)
   b=b+transfer(k(pos+1),b)
  case(3)
   a=a+transfer(k(pos),a)
   b=b+transfer(k(pos+1),b)
   c=c+transfer(k(pos+2),c)
  case default
 end select

 call final(a,b,c)

end function

pure function hashint32_scal(k, seed) result(c)
 integer(int32), intent(in) :: k
 integer(int32), intent(in), optional :: seed
 integer(int32) :: c
 
 integer(int32) :: lenk, length, i
 integer(int32), allocatable :: kint32(:)

 allocate(kint32(1))
 kint32 = k
 
 if(present(seed))then
  c = hashint32(kint32, seed)
 else
  c = hashint32(kint32)
 endif
end function

pure function hashreal32_scal(k, seed) result(c)
 real(real32), intent(in) :: k
 integer(int32), intent(in), optional :: seed
 integer(int32) :: c
 
 integer(int32) :: lenk, length, i
 integer(int32), allocatable :: kint32(:)

 allocate(kint32(1))
 kint32(1) = transfer(k, kint32(1))
 
 if(present(seed))then
  c = hashint32(kint32, seed)
 else
  c = hashint32(kint32)
 endif
end function


elemental pure function roundinguppower2(x) result(next)
 integer(kind=int32),intent(in)::x
 integer(kind=int32)::next

 !https://stackoverflow.com/questions/466204/rounding-up-to-next-power-of-2
 
 next=2_int32**int((ceiling(log(real(x,real64))/log(real(2,real64)))),int32)

end function

!PRIVATE
    
pure subroutine mix(a,b,c)
 integer(kind=int32),intent(inout)::a,b,c

 a=a-c;a=ieor(a,rot(c,4_int32));c=c+b 
 b=b-a;b=ieor(b,rot(a,6_int32));a=a+c 
 c=c-b;c=ieor(c,rot(b,8_int32));b=b+a 
 a=a-c;a=ieor(a,rot(c,16_int32));c=c+b 
 b=b-a;b=ieor(b,rot(a,19_int32));a=a+c 
 c=c-b;c=ieor(c,rot(b,4_int32));b=b+a 

end subroutine 

pure subroutine final(a,b,c)
 integer(kind=int32),intent(inout)::a,b,c

 c=ieor(c,b); c=c-rot(b,14_int32)
 a=ieor(a,c); a=a-rot(c,11_int32)
 b=ieor(b,a); b=b-rot(a,25_int32)
 c=ieor(c,b); c=c-rot(b,16_int32)
 a=ieor(a,c); a=a-rot(c,4_int32)
 b=ieor(b,a); b=b-rot(a,14_int32)
 c=ieor(c,b); c=c-rot(b,24_int32)

end subroutine

pure function rot(i,j) result(rota)
 integer(kind=int32),intent(in):: i,j
 integer(kind=int32)::rota

 rota=ior(ishft(i,j),ishft(i,-(32_int32-j)))

end function

end module

#:set TYPES = list(zip(["character(len=:)","integer(int32)", "real(real32)"],["char","int32","real32"],["character(len=*)","integer(int32)","real(real32)"]))
module modlist
 use iso_fortran_env,only:int32,real32
 use modhash, only: roundinguppower2, seed_hash, hash
 implicit none
 private
 #:for t,k,l in TYPES
 public::list${k}$_t
 #:endfor

 type, abstract :: listabstrat_t
  private
  integer(int32) :: filled
  integer(int32) :: nel
  integer(int32),allocatable::id(:)
  contains
  procedure(int_destroy_listabstract_t),public,deferred :: destroy 
  procedure :: destroy_listabstract_t
 end type

 abstract interface
  pure subroutine int_destroy_listabstract_t(this)
   import::listabstrat_t
   class(listabstrat_t),intent(inout)::this
  end subroutine
 end interface



 #:for t,k,l in TYPES
 type,extends(listabstrat_t)::list${k}$_t !(k)
  private
  !integer, len :: k
  !character(len=k),allocatable::stored(:)
  ${t}$,allocatable::stored(:)
  contains
  private
  procedure, public :: add => add_list${k}$_t
  procedure :: destroy => destroy_list${k}$_t
  procedure, public :: get => get_list${k}$_t
  procedure, public :: getindex => getindex_list${k}$_t
  procedure, public :: writetable => writetable_list${k}$_t
  final :: destroy_list${k}$_t_scal, destroy_list${k}$_t_array1
 end type

 interface list${k}$_t
  module procedure constructor_list${k}$_t
 end interface

 #:endfor

contains

pure subroutine destroy_listabstract_t(this)
 class(listabstrat_t), intent(inout) :: this

 this%filled=0
 this%nel=0
 if(allocated(this%id))deallocate(this%id)

end subroutine



#:for t,k,l in TYPES
pure function constructor_list${k}$_t(k,nel) result(this)
 type(list${k}$_t) :: this
 integer(kind=int32),intent(in), optional :: k
 integer(kind=int32),intent(in), optional :: nel

 this%nel = roundinguppower2(10)
 if(present(nel)) this%nel = roundinguppower2(nel)

 this%filled=0

 allocate(this%id(this%nel))
 this%id=0

 #:if k[0] == 'c'
 allocate(character(len=k) :: this%stored(this%nel))
 this%stored = ''
 #:else
 allocate(this%stored(this%nel))
 this%stored = 0
 #:endif

end function

recursive subroutine add_list${k}$_t(this, c, index, lnew)
 class(list${k}$_t), intent(inout) :: this
 ${l}$,intent(in) :: c
 integer(int32),intent(out),optional :: index
 logical, intent(out), optional :: lnew

 integer(int32) :: i, address
 integer(int32),parameter :: maxiter = 5000

 if(real(this%filled).gt.0.80*this%nel)call increase_size()

 address = seed_hash

 do i = 1, min(this%nel,maxiter)-1
  address = iand( hash(c, address), this%nel - 1) + 1

  if(this%id(address).eq.0)then
   this%filled = this%filled + 1
   this%id(address) = this%filled
   this%stored(this%id(address)) = c
   if(present(index)) index = this%id(address)
   if(present(lnew)) lnew = .true.
   return
  else !already occupied
   if(this%stored(this%id(address)).eq.c)then
    if(present(index)) index = this%id(address)
    if(present(lnew)) lnew = .false.
    return
   endif
  endif
 enddo

 call increase_size()

 address = seed_hash

 do i = 1, min(this%nel,maxiter)-1
  address = iand( hash(c, address), this%nel - 1) + 1

  if(this%id(address).eq.0)then
   this%filled = this%filled + 1
   this%id(address) = this%filled
   this%stored(this%id(address)) = c
   if(present(index)) index = this%id(address)
   if(present(lnew)) lnew = .true.
   return
  else !already occupied
   if(this%stored(this%id(address)).eq.c)then
    if(present(index)) index = this%id(address)
    if(present(lnew)) lnew = .false.
    return
   endif
  endif
 enddo


 address = -1
 if(present(index)) index = -1

 error stop 'too many collisions'

 contains

  subroutine increase_size()
   type(list${k}$_t) :: thistmp

   #:if k[0] == 'c'
   thistmp = list${k}$_t(len(this%stored), nel = int(this%nel*1.5, int32))
   #:else
   thistmp = list${k}$_t(nel = int(this%nel*1.5, int32))
   #:endif
  
   do i = 1, this%filled
    call thistmp%add(this%stored(i))
   enddo
  
   this%filled = thistmp%filled
   this%nel = thistmp%nel
   if(allocated(this%id)) deallocate(this%id)
   if(allocated(this%stored)) deallocate(this%stored)
   call move_alloc(thistmp%id,this%id)
   call move_alloc(thistmp%stored,this%stored)
  
  end subroutine

end subroutine

pure subroutine destroy_list${k}$_t(this)
 class(list${k}$_t), intent(inout) :: this

 call this%destroy_listabstract_t

 if(allocated(this%stored))deallocate(this%stored)

end subroutine


pure subroutine destroy_list${k}$_t_scal(this)
 type(list${k}$_t), intent(inout) :: this

 call this%destroy()

end subroutine

pure subroutine destroy_list${k}$_t_array1(this)
 type(list${k}$_t), intent(inout) :: this(:)

 integer :: i

 do i = 1, size(this)
  call this(i)%destroy()
 enddo

end subroutine

pure function get_list${k}$_t(this, index) result(c)
 class(list${k}$_t), intent(in) :: this
 integer(int32), intent(in) :: index
 #:if k[0] == 'c'
 character(len=len(this%stored)) :: c
 #:else
 ${t}$ :: c
 #:endif

 c = this%stored(index)

end function

pure function getindex_list${k}$_t(this, c) result(index)
 class(list${k}$_t), intent(in) :: this
 ${l}$,intent(in) :: c
 integer(int32) :: index

 integer(int32) :: i, address
 integer(int32),parameter :: maxiter = 5000
 type(list${k}$_t),allocatable :: thistmp

 address = seed_hash

 do i = 1, min(this%nel,maxiter)-1
  address = iand( hash(c, address), this%nel - 1) + 1

  if(this%id(address).eq.0)then
   index=0
   return
  else !occupied
   if(this%stored(this%id(address)).eq.c)then
    index = this%id(address)
    return
   endif
  endif
 enddo

 index = -1

end function

subroutine writetable_list${k}$_t(this, namefile)
 class(list${k}$_t), intent(in) :: this
 character(*), intent(in) :: namefile

 integer :: i, un
 
 open(newunit=un, file=namefile, action = 'write')
 do i = 1, this%filled
  write(un,'(i0,x,g0)')i,this%get(i)
 enddo
 close(un)

end subroutine

#:endfor

end module

program test
 use modhash
 use modlist, only: listchar_t, listint32_t,listreal32_t
 use iso_fortran_env,only:int32,int64,real64
 implicit none
 integer(int32) :: dim
 type(listchar_t) :: list
 type(listint32_t) :: list32
 type(listreal32_t) :: listr32

 dim=roundinguppower2(1000)

 print*,hash([1,2,3,4,5]),iand(hash([1,2,3,4,5]),dim-1)+1
 print*,hash([1,2,3,4,5,6,7,8,9]),iand(hash([1,2,3,4,5,6,7,8,9]),dim-1)+1
 print*,hash([1,2,3,4,5,6,7,8,9,10]),iand(hash([1,2,3,4,5,6,7,8,9,10]),dim-1)+1
 print*,hash([1,2,3]),iand(hash([1,2,3]),dim-1)+1
 print*,hash([1,2]),iand(hash([1,2]),dim-1)+1


 print*,'aaa ',hash('a')
 print*,'aaa ',hash('ab')
 print*,'aaa ',hash('abc')
 print*,'aaa ',hash('abc ')
 print*,'aaa ',hash(' abc')
 print*,'aaa ',hash(' abc  afafa')
 print*,'aaa ',hash(' abc  afafa 1234566')
 print*,'aaa ',hash(' abc  afafa 1234566 pppppppppp')

 list = listchar_t(12)

 call list%add('a')
 call list%add('ab')
 call list%add('abc')
 call list%add('abcdd')
 call list%add('1')
 call list%add('12')
 call list%add('123')
 call list%add('1234')
 call list%add('12345')
 call list%add('12346')
 call list%add('12347')
 call list%add('12348')
 call list%writetable('list0.dat')
 call list%add('12349')
 call list%add('12350')
 call list%add('12351')
 call list%add('12352')
 call list%add('12353')
 call list%add('12353')
 call list%add('12353')

 call list%writetable('list.dat')

 list32 = listint32_t()

 call list32%add(1)
 call list32%add(2)
 call list32%add(5)
 call list32%writetable('listint32.dat')

 listr32 = listreal32_t()

 call listr32%add(1.)
 call listr32%add(2.)
 call listr32%add(5.)
 call listr32%writetable('listreal32.dat')


end program
